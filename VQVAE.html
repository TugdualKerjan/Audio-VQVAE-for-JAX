<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tugdual Kerjan">
<meta name="dcterms.date" content="2024-11-06">

<title>Implementing a VQVAE in JAX for fun 😎</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="VQVAE_files/libs/clipboard/clipboard.min.js"></script>
<script src="VQVAE_files/libs/quarto-html/quarto.js"></script>
<script src="VQVAE_files/libs/quarto-html/popper.min.js"></script>
<script src="VQVAE_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="VQVAE_files/libs/quarto-html/anchor.min.js"></script>
<link href="VQVAE_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="VQVAE_files/libs/quarto-html/quarto-syntax-highlighting-2486e1f0a3ee9ee1fc393803a1361cdb.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="VQVAE_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="VQVAE_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="VQVAE_files/libs/bootstrap/bootstrap-ce986950bcdadb6c49cd29bd6d64e019.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="VQVAE_files/libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="VQVAE_files/libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="VQVAE_files/libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Implementing a VQVAE in JAX for fun 😎</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p><a href="https://tugdual.fr">Tugdual Kerjan</a> <a href="mailto:tkerjan@outlook.com" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 6, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="context" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Context 👀</h1>
<p>I’m trying to rewrite XTTS in JAX to understand how it works.</p>
<p>We are going to implement the VQVAE used in <span class="citation" data-cites="casanova2024xttsmassivelymultilingualzeroshot">(<a href="#ref-casanova2024xttsmassivelymultilingualzeroshot" role="doc-biblioref">Casanova et al. 2024</a>)</span>, a Text to Speech model written by the defunct Coqai company. VQVAEs come from <span class="citation" data-cites="oord2018neuraldiscreterepresentationlearning">(<a href="#ref-oord2018neuraldiscreterepresentationlearning" role="doc-biblioref">Oord, Vinyals, and Kavukcuoglu 2018</a>)</span></p>
<p>VQVAE means Vector Quantized Variational AutoEncoder. Let’s break down the name.</p>
<p><strong>Auto-Encoder</strong></p>
<p>This model takes the input, passes it through smaller layers (Encodes) and tries to, from that small layer, reproduce the input (Decodes). It thus needs to learn what are the most important features to keep ! If the input was images of cats, the model would keep information about the color, way it’s looking, thiccness of the cat.</p>
<p><strong>Variational</strong></p>
<p>Instead of having to encode inputs onto points in space we map them onto distributions. In our case, we simply want to make sure that on average, the space we’re mapping to is uniform. This means all <em>codes</em> will be used.</p>
<p><strong>Vector Quantized</strong></p>
<p>We want to define a set of points in the smaller representation, the latent. These points will be called <em>codes</em> and be part of a <em>codebook</em>. Think of the codebook as the set of possible words the encoder can use to describe what it sees to the decoder. Obviously, the more codes we have, the more information the encoder will be able to pass per code sent.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="assets/vqvae.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Overview of the model [@csdn_image_2024]"><img src="assets/vqvae.png" class="img-fluid figure-img" alt="Overview of the model (平亦舸 2024)"></a></p>
<figcaption>Overview of the model <span class="citation" data-cites="csdn_image_2024">(<a href="#ref-csdn_image_2024" role="doc-biblioref">平亦舸 2024</a>)</span></figcaption>
</figure>
</div>
</section>
<section id="goal" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Goal 🎯</h1>
<p>Our VQVAE is going to find the best codes that describe speech. It’ll take in special images called Mel-Frequency Spectrograms, which is basically a way to represent human speech.</p>
<p>Since our final goal is to recreate a 1 to 1 version of the VQVAE used in XTTS, we’ll hardcode a lot of things to minimize issues.</p>
<div id="cell-2" class="cell" data-execution_count="50">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>DiscreteVAE(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  (discrete_loss): DiscretizationLoss()</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  (encoder): Sequential(</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>): Sequential(</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">0</span>): Conv1d(<span class="dv">80</span>, <span class="dv">512</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">2</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">1</span>): ReLU()</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>): Sequential(</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">0</span>): Conv1d(<span class="dv">512</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">2</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">1</span>): ReLU()</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2</span>): ResBlock(</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>      (net): Sequential(</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">0</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">1</span>): ReLU()</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">2</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">3</span>): ReLU()</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">4</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">1</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">3</span>): ResBlock(</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>      (net): Sequential(</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">0</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">1</span>): ReLU()</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">2</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">3</span>): ReLU()</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">4</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">1</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">4</span>): ResBlock(</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>      (net): Sequential(</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">0</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">1</span>): ReLU()</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">2</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">3</span>): ReLU()</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">4</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">1</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">5</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">512</span>, kernel_size<span class="op">=</span>(<span class="dv">1</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>  (decoder): Sequential(</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>): Conv1d(<span class="dv">512</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">1</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>): ResBlock(</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>      (net): Sequential(</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">0</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">1</span>): ReLU()</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">2</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">3</span>): ReLU()</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">4</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">1</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2</span>): ResBlock(</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>      (net): Sequential(</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">0</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">1</span>): ReLU()</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">2</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">3</span>): ReLU()</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">4</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">1</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">3</span>): ResBlock(</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>      (net): Sequential(</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">0</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">1</span>): ReLU()</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">2</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">3</span>): ReLU()</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">4</span>): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">1</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">4</span>): Sequential(</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">0</span>): UpsampledConv(</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>        (conv): Conv1d(<span class="dv">1024</span>, <span class="dv">1024</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">1</span>): ReLU()</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">5</span>): Sequential(</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">0</span>): UpsampledConv(</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>        (conv): Conv1d(<span class="dv">1024</span>, <span class="dv">512</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,), padding<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">1</span>): ReLU()</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">6</span>): Conv1d(<span class="dv">512</span>, <span class="dv">80</span>, kernel_size<span class="op">=</span>(<span class="dv">1</span>,), stride<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>  (codebook): Quantize()</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="model" class="level1 page-columns page-full" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Model</h1>
<p>We have 4 parts to code: An ResBlock, Encoder, a Decoder and a Quantizer. Let’s get into it!</p>
<p>Importing JAX and Equinox, a library that helps with writing neural networks.</p>
<div id="cell-5" class="cell" data-tags="[&quot;export&quot;]" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> equinox <span class="im">as</span> eqx</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> equinox.nn <span class="im">as</span> nn</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> typing <span class="im">as</span> tp</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="resblocks" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="resblocks"><span class="header-section-number">3.1</span> ResBlocks</h2>
<p>The role of this Block is to mainly exchange information between the various parts of each channel, but the input is added at the end. This allows our network to basically, if suitable, simply put all weights to zero and be “Shallower” basically our network decides how many layers it needs !</p>
<div id="cell-7" class="cell" data-tags="[&quot;export&quot;]" data-execution_count="54">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ResBlock(eqx.Module):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    conv1: nn.Conv1d</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    conv2: nn.Conv1d</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    conv3: nn.Conv1d</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    act: tp.Callable <span class="op">=</span> eqx.static_field()</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dim: <span class="bu">int</span>, activation <span class="op">=</span> jax.nn.relu, key<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        key1, key2, key3 <span class="op">=</span> jax.random.split(key, <span class="dv">3</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv1 <span class="op">=</span> nn.Conv1d(dim, dim, kernel_size<span class="op">=</span><span class="dv">3</span>, padding<span class="op">=</span><span class="st">"SAME"</span>, key<span class="op">=</span>key1)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv2 <span class="op">=</span> nn.Conv1d(dim, dim, kernel_size<span class="op">=</span><span class="dv">3</span>, padding<span class="op">=</span><span class="st">"SAME"</span>, key<span class="op">=</span>key2)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv3 <span class="op">=</span> nn.Conv1d(dim, dim, kernel_size<span class="op">=</span><span class="dv">1</span>, padding<span class="op">=</span><span class="st">"SAME"</span>, key<span class="op">=</span>key3)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.act <span class="op">=</span> activation</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> x</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.conv1(y)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> jax.nn.relu(y)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.conv2(y)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> jax.nn.relu(y)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.conv3(y)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> y <span class="op">+</span> x</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="encoder" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="encoder"><span class="header-section-number">3.2</span> Encoder</h2>
<p>Moving onto the Encoder. It has layers that take in the input, and slowly compress it by lowering the image dimensions and increasing the amounts of channels, much like ResNet:</p>
<div id="fig-encode" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-encode-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="VQVAE_files/figure-html/cell-8-1-image.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Visualisation of what the encoder is doing [@dumakude2023automated_image]"><img src="VQVAE_files/figure-html/cell-8-1-image.png" class="img-fluid figure-img"></a></p>
<figcaption>Visualisation of what the encoder is doing <span class="citation" data-cites="dumakude2023automated_image">(<a href="#ref-dumakude2023automated_image" role="doc-biblioref">Dumakude and Ezugwu 2023</a>)</span></figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-encode-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1
</figcaption>
</figure>
</div>
<div id="cell-9" class="cell" data-tags="[&quot;export&quot;]" data-execution_count="55">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Encoder(eqx.Module):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    conv1: nn.Conv1d</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    conv2: nn.Conv1d</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    conv3: nn.Conv1d</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    res1: ResBlock</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    res2: ResBlock</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    res3: ResBlock</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, hidden_dim: <span class="bu">int</span> <span class="op">=</span> <span class="dv">1024</span>, codebook_dim: <span class="bu">int</span> <span class="op">=</span> <span class="dv">512</span>, key<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        key1, key2, key3, key4, key5, key6 <span class="op">=</span> jax.random.split(key, <span class="dv">6</span>)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv1 <span class="op">=</span> nn.Conv1d(in_channels<span class="op">=</span><span class="dv">80</span>, out_channels<span class="op">=</span><span class="dv">512</span>, kernel_size<span class="op">=</span><span class="dv">3</span>, stride<span class="op">=</span><span class="dv">2</span>, padding<span class="op">=</span><span class="st">"SAME"</span>, key<span class="op">=</span>key1)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv2 <span class="op">=</span> nn.Conv1d(in_channels<span class="op">=</span><span class="dv">512</span>, out_channels<span class="op">=</span>hidden_dim, kernel_size<span class="op">=</span><span class="dv">3</span>, stride<span class="op">=</span><span class="dv">2</span>, padding<span class="op">=</span><span class="st">"SAME"</span>, key<span class="op">=</span>key2)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.res1 <span class="op">=</span> ResBlock(dim<span class="op">=</span>hidden_dim, key<span class="op">=</span>key3)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.res2 <span class="op">=</span> ResBlock(dim<span class="op">=</span>hidden_dim, key<span class="op">=</span>key4)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.res3 <span class="op">=</span> ResBlock(dim<span class="op">=</span>hidden_dim, key<span class="op">=</span>key5)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv3 <span class="op">=</span> nn.Conv1d(in_channels<span class="op">=</span>hidden_dim, out_channels<span class="op">=</span>codebook_dim, kernel_size<span class="op">=</span><span class="dv">1</span>, stride<span class="op">=</span><span class="dv">1</span>, padding<span class="op">=</span><span class="st">"SAME"</span>, key<span class="op">=</span>key6)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.conv1(x)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> jax.nn.relu(y)</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.conv2(y)</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> jax.nn.relu(y)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.res1(y)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.res2(y)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.res3(y)</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.conv3(y)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="decoder" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="decoder"><span class="header-section-number">3.3</span> Decoder</h2>
<p>We can now implement the decoder. Instead of using ConvTranspose1d here XTTS uses upsampling and interpolation between points, replacing the striding that would usually happen. We implement it just below <a href="#sec-plot" class="quarto-xref">Section&nbsp;3.3.1</a></p>
<div id="cell-11" class="cell" data-tags="[&quot;export&quot;]" data-execution_count="60">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Decoder(eqx.Module):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    conv1: nn.Conv1d</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    conv2: UpsampledConv</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    conv3: UpsampledConv</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    conv4: nn.Conv1d</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    res1: ResBlock</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    res2: ResBlock</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    res3: ResBlock</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, hidden_dim: <span class="bu">int</span> <span class="op">=</span> <span class="dv">1024</span>, codebook_dim: <span class="bu">int</span> <span class="op">=</span> <span class="dv">512</span>, key<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        key1, key2, key3, key4, key5, key6, key7 <span class="op">=</span> jax.random.split(key, <span class="dv">7</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv1 <span class="op">=</span> nn.Conv1d(in_channels<span class="op">=</span>codebook_dim, out_channels<span class="op">=</span>hidden_dim, kernel_size<span class="op">=</span><span class="dv">1</span>, stride<span class="op">=</span><span class="dv">1</span>, padding<span class="op">=</span><span class="st">"SAME"</span>, key<span class="op">=</span>key1)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.res1 <span class="op">=</span> ResBlock(dim<span class="op">=</span>hidden_dim, key<span class="op">=</span>key2)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.res2 <span class="op">=</span> ResBlock(dim<span class="op">=</span>hidden_dim, key<span class="op">=</span>key3)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.res3 <span class="op">=</span> ResBlock(dim<span class="op">=</span>hidden_dim, key<span class="op">=</span>key4)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv2 <span class="op">=</span> UpsampledConv(in_channels<span class="op">=</span>hidden_dim, out_channels<span class="op">=</span>hidden_dim, kernel_size<span class="op">=</span><span class="dv">3</span>, stride<span class="op">=</span><span class="dv">2</span>, padding<span class="op">=</span><span class="st">"SAME"</span>, key<span class="op">=</span>key5)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv3 <span class="op">=</span> UpsampledConv(in_channels<span class="op">=</span>hidden_dim, out_channels<span class="op">=</span><span class="dv">512</span>, kernel_size<span class="op">=</span><span class="dv">3</span>, stride<span class="op">=</span><span class="dv">2</span>, padding<span class="op">=</span><span class="st">"SAME"</span>, key<span class="op">=</span>key6)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv4 <span class="op">=</span> nn.Conv1d(in_channels<span class="op">=</span><span class="dv">512</span>, out_channels<span class="op">=</span><span class="dv">80</span>, kernel_size<span class="op">=</span><span class="dv">1</span>, stride<span class="op">=</span><span class="dv">1</span>, padding<span class="op">=</span><span class="st">"SAME"</span>, key<span class="op">=</span>key7)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.conv1(x)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.res1(y)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.res2(y)</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.res3(y)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.conv2(y)</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> jax.nn.relu(y)</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.conv3(y)</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> jax.nn.relu(y)</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.conv4(y)</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="sec-plot" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="sec-plot"><span class="header-section-number">3.3.1</span> UpsampledConv</h3>
<p>Before we move onto the decoder we have to define a special layer that replaces the ConvTranspose that we would normally use. TODO understand I admit I still am still not sure why they use this instead.</p>
<p>Their code for this function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> UpsampledConv(nn.Module):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, conv, <span class="op">*</span>args, <span class="op">**</span>kwargs):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="st">"stride"</span> <span class="kw">in</span> kwargs.keys()</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stride <span class="op">=</span> kwargs[<span class="st">"stride"</span>]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> kwargs[<span class="st">"stride"</span>]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv <span class="op">=</span> conv(<span class="op">*</span>args, <span class="op">**</span>kwargs)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        up <span class="op">=</span> nn.functional.interpolate(x, scale_factor<span class="op">=</span><span class="va">self</span>.stride, mode<span class="op">=</span><span class="st">"nearest"</span>)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.conv(up)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can execute the torch version to check how it works and then compare to our solution</p>
<div id="cell-14" class="cell" data-execution_count="57">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> UpsampledConv(torch.nn.Module):</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, conv, <span class="op">*</span>args, <span class="op">**</span>kwargs):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="st">"stride"</span> <span class="kw">in</span> kwargs.keys()</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stride <span class="op">=</span> kwargs[<span class="st">"stride"</span>]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> kwargs[<span class="st">"stride"</span>]</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv <span class="op">=</span> conv(<span class="op">*</span>args, <span class="op">**</span>kwargs)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        up <span class="op">=</span> torch.nn.functional.interpolate(x, scale_factor<span class="op">=</span><span class="va">self</span>.stride, mode<span class="op">=</span><span class="st">"nearest"</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(up.shape)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.conv(up)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>upsamp <span class="op">=</span> UpsampledConv(torch.nn.Conv1d, <span class="dv">80</span>, <span class="dv">512</span>, <span class="dv">3</span>, stride<span class="op">=</span><span class="dv">2</span>, padding<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> torch.ones((<span class="dv">3</span>, <span class="dv">80</span>, <span class="dv">100</span>))</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(upsamp(x).shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can then write our own version using JAX.</p>
<div id="upsample" class="cell" data-tags="[&quot;export&quot;]" data-execution_count="59">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> UpsampledConv(eqx.Module):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    conv: nn.Conv1d</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    stride: <span class="bu">int</span> <span class="op">=</span> eqx.static_field()</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, in_channels:<span class="bu">int</span>, out_channels:<span class="bu">int</span>, kernel_size:tp.Union[<span class="bu">int</span>, tp.Tuple[<span class="bu">int</span>]], stride:<span class="bu">int</span>, padding:tp.Union[<span class="bu">int</span>, <span class="bu">str</span>], key<span class="op">=</span><span class="va">None</span> ):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stride <span class="op">=</span> stride</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv <span class="op">=</span> nn.Conv1d(in_channels<span class="op">=</span>in_channels, out_channels<span class="op">=</span>out_channels, kernel_size<span class="op">=</span>kernel_size, stride<span class="op">=</span><span class="dv">1</span>, padding<span class="op">=</span>padding, key<span class="op">=</span>key)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        upsampled_size <span class="op">=</span> (x.shape[<span class="dv">0</span>], x.shape[<span class="dv">1</span>] <span class="op">*</span> <span class="va">self</span>.stride)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        upsampled <span class="op">=</span> jax.image.resize(x, upsampled_size, method<span class="op">=</span><span class="st">"nearest"</span>)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.conv(upsampled)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Running the code below allows to do a quick check to see it works well</p>
<div id="cell-18" class="cell" data-execution_count="43">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>key <span class="op">=</span> jax.random.PRNGKey(<span class="dv">1</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>upsamp <span class="op">=</span> UpsampledConv(<span class="dv">80</span>, <span class="dv">150</span>, kernel_size<span class="op">=</span><span class="dv">3</span>, stride<span class="op">=</span><span class="dv">2</span>, padding<span class="op">=</span><span class="st">"SAME"</span>, key<span class="op">=</span>key)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> jax.random.normal(key, shape<span class="op">=</span>(<span class="dv">80</span>, <span class="dv">100</span>))</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> upsamp(x)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(x.shape)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(y.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>After having implemented various VQVAEs, what strikes me in this one is that the ResBlocks are all seperated from the various convolutional stages, and the lack of normalisation between layers. Moving onto the crux of the matter, the Quantizer !</p>
</section>
</section>
<section id="quantizer" class="level2 page-columns page-full" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="quantizer"><span class="header-section-number">3.4</span> Quantizer</h2>
<p>So our encoder spits out a certain number of vectors (The number of channels) with the codebook dim. These vectors are mapped to their nearest neighbors, and these are then transmitted to the decoder. To stabalise the model, we’re going to also add some exponential moving average to the codebook, as well as normalize things so as to keep things from exploding or minimizing. Exponential moving average meaning that we basically mostly keep what we currently have and add a little of the new stuff instead of fully changing things every time.</p>
<p><span class="math display">\[{Codebook} = {Codebook}_{old} * decay + {Codebook}_{new} * (1 - decay)\]</span></p>
<p>We can’t update the codebook here though, as this is immutable stuff. We need to update it between each training instead.</p>
<div id="cell-21" class="cell" data-tags="[&quot;export&quot;]" data-execution_count="3">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Quantizer(eqx.Module):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    K: <span class="bu">int</span> <span class="op">=</span> eqx.static_field()</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    D: <span class="bu">int</span> <span class="op">=</span> eqx.static_field()</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    codebook: jax.Array</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    codebook_avg: jax.Array</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    cluster_size: jax.Array</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    decay: <span class="bu">float</span> <span class="op">=</span> eqx.static_field()</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    eps: <span class="bu">float</span> <span class="op">=</span> eqx.static_field()</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_vecs: <span class="bu">int</span> <span class="op">=</span> <span class="dv">1024</span>, num_dims: <span class="bu">int</span> <span class="op">=</span> <span class="dv">512</span>, decay: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.99</span>, eps: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-5</span>, key<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.K <span class="op">=</span> num_vecs</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.D <span class="op">=</span> num_dims</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.decay <span class="op">=</span> decay</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.eps <span class="op">=</span> eps</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Init a matrix of vectors that will move with time</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.codebook <span class="op">=</span> jax.nn.initializers.variance_scaling(scale<span class="op">=</span><span class="fl">1.0</span>, mode<span class="op">=</span><span class="st">"fan_in"</span>, distribution<span class="op">=</span><span class="st">"uniform"</span>)(key, (num_vecs, num_dims))</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.codebook_avg <span class="op">=</span> jnp.copy(<span class="va">self</span>.codebook)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cluster_size <span class="op">=</span> jnp.zeros(num_vecs)</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># x has N vectors of the codebook dimension. We calculate the nearest neighbors and output those instead</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>        flatten <span class="op">=</span> jax.numpy.reshape(x, (<span class="op">-</span><span class="dv">1</span>, <span class="va">self</span>.D))</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>        a_squared <span class="op">=</span> jnp.<span class="bu">sum</span>(flatten<span class="op">**</span><span class="dv">2</span>, axis<span class="op">=-</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>        b_squared <span class="op">=</span> jnp.transpose(jnp.<span class="bu">sum</span>(<span class="va">self</span>.codebook<span class="op">**</span><span class="dv">2</span>, axis<span class="op">=-</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>        distance <span class="op">=</span> a_squared <span class="op">+</span> b_squared <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>jnp.matmul(flatten, jnp.transpose(<span class="va">self</span>.codebook))</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>        codebook_indices <span class="op">=</span> jnp.argmin(distance, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>        z_q <span class="op">=</span> <span class="va">self</span>.codebook[codebook_indices]</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Straight-through estimator</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>        z_q <span class="op">=</span> flatten <span class="op">+</span> jax.lax.stop_gradient(z_q <span class="op">-</span> flatten)</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>        z_q <span class="op">=</span> jax.numpy.permute_dims(z_q, (<span class="dv">1</span>, <span class="dv">0</span>))</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> z_q, <span class="va">self</span>.codebook_updates(flatten, codebook_indices)</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> codebook_updates(<span class="va">self</span>, flatten, codebook_indices):</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate the usage of various codes.</span></span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>        codebook_onehot <span class="op">=</span> jax.nn.one_hot(codebook_indices, <span class="va">self</span>.K)</span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>        codebook_onehot_sum <span class="op">=</span> jnp.<span class="bu">sum</span>(codebook_onehot, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a>        codebook_sum <span class="op">=</span> jnp.dot(flatten.T, codebook_onehot)</span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># We've just weighed the codebook vectors.</span></span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Basically count on average how many codes we're using</span></span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a>        new_cluster_size <span class="op">=</span> <span class="va">self</span>.decay <span class="op">*</span> <span class="va">self</span>.cluster_size <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.decay) <span class="op">*</span> codebook_onehot_sum</span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Where is the average embedding at ?</span></span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a>        new_codebook_avg <span class="op">=</span> <span class="va">self</span>.decay <span class="op">*</span> <span class="va">self</span>.codebook_avg <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.decay) <span class="op">*</span> codebook_sum.T</span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-58"><a href="#cb10-58" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> jnp.<span class="bu">sum</span>(new_cluster_size) <span class="co"># Over the total embeddings used</span></span>
<span id="cb10-59"><a href="#cb10-59" aria-hidden="true" tabindex="-1"></a>        new_cluster_size <span class="op">=</span> (new_cluster_size <span class="op">+</span> <span class="va">self</span>.eps) <span class="op">/</span> (n <span class="op">+</span> <span class="va">self</span>.K <span class="op">*</span> <span class="va">self</span>.eps) <span class="op">*</span> n</span>
<span id="cb10-60"><a href="#cb10-60" aria-hidden="true" tabindex="-1"></a>        new_codebook <span class="op">=</span> <span class="va">self</span>.codebook_avg <span class="op">/</span> new_cluster_size[:, <span class="va">None</span>]</span>
<span id="cb10-61"><a href="#cb10-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-62"><a href="#cb10-62" aria-hidden="true" tabindex="-1"></a>        updates <span class="op">=</span> (new_cluster_size, new_codebook_avg, new_codebook)</span>
<span id="cb10-63"><a href="#cb10-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-64"><a href="#cb10-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> updates, codebook_indices</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can visualize vectors being mapped to the neasest codes below, where light blue vectors come in, and are snapped to the closest red vectors. TODO fix the bug</p>
<div id="cell-quantized" class="cell page-columns page-full" data-execution_count="4">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>key <span class="op">=</span> jax.random.PRNGKey(<span class="dv">3</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>key1, key2 <span class="op">=</span> jax.random.split(key)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>quantizer <span class="op">=</span> Quantizer(<span class="dv">7</span>, <span class="dv">2</span>, key<span class="op">=</span>key1)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> jax.random.normal(key2, shape<span class="op">=</span>(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>)) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>y, _ <span class="op">=</span> jax.vmap(quantizer)(x)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">8</span>))</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>axs <span class="op">=</span> axs.flatten()  <span class="co"># Flatten for easy iteration</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot data on each subplot (adjust as needed)</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, ax <span class="kw">in</span> <span class="bu">enumerate</span>(axs):</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    origin_x <span class="op">=</span> jnp.zeros(<span class="dv">3</span>)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    origin_y <span class="op">=</span> jnp.zeros(<span class="dv">3</span>)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot arrows with quiver</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    ax.quiver(origin_x, origin_y, y[i, <span class="dv">1</span>, :], y[i, <span class="dv">0</span>, :], angles<span class="op">=</span><span class="st">'xy'</span>, scale_units<span class="op">=</span><span class="st">'xy'</span>, scale<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    ax.quiver(origin_x, origin_y, x[i, <span class="dv">1</span>, :], x[i, <span class="dv">0</span>, :], angles<span class="op">=</span><span class="st">'xy'</span>, scale_units<span class="op">=</span><span class="st">'xy'</span>, scale<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">"blue"</span>, alpha<span class="op">=</span><span class="fl">0.6</span>)</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    ax.quiver(</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>        jnp.zeros(quantizer.codebook.shape[<span class="dv">0</span>]), jnp.zeros(quantizer.codebook.shape[<span class="dv">0</span>]), quantizer.codebook[:, <span class="dv">1</span>], quantizer.codebook[:, <span class="dv">0</span>], angles<span class="op">=</span><span class="st">'xy'</span>, scale_units<span class="op">=</span><span class="st">'xy'</span>, scale<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span> </span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    ax.set_xlim(<span class="op">-</span><span class="fl">0.7</span>, <span class="fl">0.7</span>)  <span class="co"># Adjust limits as needed</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim(<span class="op">-</span><span class="fl">0.7</span>, <span class="fl">0.7</span>)</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    ax.set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f"Example </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">"x"</span>)</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">"y"</span>)</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the figure</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>

<div class="no-row-height column-margin column-container"><div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="VQVAE_files/figure-html/quantized-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Vectors finding the nearest code"><img src="VQVAE_files/figure-html/quantized-output-1.png" class="img-fluid figure-img" alt="Vectors finding the nearest code"></a></p>
<figcaption>Vectors finding the nearest code</figcaption>
</figure>
</div>
</div></div></div>
<p>What the above does is create K vectors in D dimensional space. Incoming vectors find their nearest match and the loss calculated is the L2 distance.</p>
</section>
<section id="vqvae" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="vqvae"><span class="header-section-number">3.5</span> VQVAE</h2>
<p>Let’s finish up by defining a final Module that wraps all of this up, and defining our training.</p>
<div id="cell-26" class="cell" data-tags="[&quot;export&quot;]" data-execution_count="62">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VQVAE(eqx.Module):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    encoder: Encoder</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    decoder: Decoder</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    quantizer: Quantizer</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, key<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        key1, key2, key3 <span class="op">=</span> jax.random.split(key, <span class="dv">3</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.encoder <span class="op">=</span> Encoder(key<span class="op">=</span>key1)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.decoder <span class="op">=</span> Decoder(key<span class="op">=</span>key2)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.quantizer <span class="op">=</span> Quantizer(decay<span class="op">=</span><span class="fl">0.8</span>, key<span class="op">=</span>key3)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        z_e <span class="op">=</span> <span class="va">self</span>.encoder(x)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        z_q, codebook_indices <span class="op">=</span> <span class="va">self</span>.quantizer(z_e)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="va">self</span>.decoder(z_q)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> z_e, z_q, codebook_indices, y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s do a quick test on the full model to make sure that the whole works correctly.</p>
<div id="cell-28" class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>key1, key2 <span class="op">=</span> jax.random.split(jax.random.PRNGKey(<span class="dv">69</span>))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> VQVAE(key1)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> jax.random.normal(key2, shape<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">80</span>, <span class="dv">400</span>))</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>z_e, z_q, _, y<span class="op">=</span> jax.vmap(model)(x)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(x.shape)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(z_e.shape)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(z_q.shape)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(y.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(10, 80, 400)
(10, 512, 100)
(10, 512, 100)
(10, 80, 400)</code></pre>
</div>
</div>
<p>We can see that we go from a <span class="math inline">\([80 \times X]\)</span> long spectrogram and go down to a <span class="math inline">\([512 \times \frac{X}{4}]\)</span> image, which to be fair seems kind of dumb because we actually don’t loose any information like this. We could have a 1 to 1 reproduction of the image… was it not for the quantizer in the middle that forces us to assign the image to actually, only <span class="math inline">\(\frac{X}{4}\)</span> vectors ! Whatever the dimension of these vectors, the information we encode can this be counted in <span class="math inline">\(log_2(x/4)\)</span> bits which makes it quite small 🤏😎</p>
</section>
</section>
<section id="training" class="level1 page-columns page-full" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Training</h1>

<div class="no-row-height column-margin column-container"><div id="fig-table" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="assets/chaos.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Figure&nbsp;2: How not to train things"><img src="assets/chaos.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: How not to train things
</figcaption>
</figure>
</div></div><section id="codebook-special-thingies" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="codebook-special-thingies"><span class="header-section-number">4.1</span> Codebook special thingies</h2>
<p>There are a few things that we need to do. First we need to write a function that will update our model based on the passed <span class="math inline">\({Codebook}\)</span>. It should not only update the various values we’re keeping track of, but since we’re using a VQVAE and that they impose that the distribution is <strong>uniform</strong> this means that we need to yeet codes that are being used too often.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>VAEs work because we impose that they don’t just encode important information but they encode it in a uniform way, so that vectors are well spread out and not clustered. Normally you need to add a loss term checking at what point the embeddings follow that spread (usually a guassian distribution). In VQ-VAEs we impose the distribution to be uniform, making this term constant and thus we don’t have to add it in the loss</p>
</div>
</div>
<div>

</div>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-surus" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-surus-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="assets/spread.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Figure&nbsp;3: With replacing codebook outliers"><img src="assets/spread.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-surus-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: With replacing codebook outliers
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-hanno" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hanno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="assets/close.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Figure&nbsp;4: Without replacement"><img src="assets/close.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hanno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Without replacement
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="cell-35" class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> optax</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tensorboardX <span class="im">import</span> SummaryWriter</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update_codebook_ema(model: VQVAE, updates: <span class="bu">tuple</span>, codebook_indices, key<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    avg_updates <span class="op">=</span> jax.tree.<span class="bu">map</span>(<span class="kw">lambda</span> x: jax.numpy.mean(x, axis<span class="op">=</span><span class="dv">0</span>), updates)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate which codes are too often used and yeet them. Prior is uniform.</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> jnp.histogram(codebook_indices, bins<span class="op">=</span>model.quantizer.K, <span class="bu">range</span><span class="op">=</span>(<span class="dv">0</span>, model.quantizer.K))[<span class="dv">0</span>] <span class="op">/</span> <span class="bu">len</span>(codebook_indices)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    part_that_should_be <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>model.quantizer.K</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> (h <span class="op">&gt;</span> <span class="dv">2</span> <span class="op">*</span> part_that_should_be) <span class="op">|</span> (h <span class="op">&lt;</span> <span class="fl">0.5</span> <span class="op">*</span> part_that_should_be)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    rand_embed <span class="op">=</span> jax.random.normal(key, (model.quantizer.K, model.quantizer.D)) <span class="op">*</span> mask[:, <span class="va">None</span>]</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    avg_updates <span class="op">=</span> (avg_updates[<span class="dv">0</span>], avg_updates[<span class="dv">1</span>], jnp.where(mask[:, <span class="va">None</span>], rand_embed, avg_updates[<span class="dv">2</span>]))</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    where <span class="op">=</span> <span class="kw">lambda</span> q: (q.quantizer.cluster_size, q.quantizer.codebook_avg, q.quantizer.codebook)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Update the codebook and other trackers.</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> eqx.tree_at(where, model, avg_updates)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> model</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="losses-and-gradients" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="losses-and-gradients"><span class="header-section-number">4.2</span> Losses and gradients</h2>
<p>Nearly there ! 😮‍💨 We can now write out our two “classic” functions, that will 1. Calculate at what point our boi outputs garbage or not, by comparing outputs to inputs using Mean Square Error, and at what point the encoder is outputing vectors that are close to the codes available.</p>
<div id="cell-37" class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="at">@eqx.filter_jit</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="at">@eqx.filter_value_and_grad</span>(has_aux<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_losses(model, x):</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    z_e, z_q, codebook_updates, y <span class="op">=</span> jax.vmap(model)(x)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Are the inputs and outputs close?</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    reconstruct_loss <span class="op">=</span> jnp.mean(jnp.linalg.norm((x <span class="op">-</span> y), <span class="bu">ord</span><span class="op">=</span><span class="dv">2</span>, axis<span class="op">=</span>(<span class="dv">1</span>,<span class="dv">2</span>)))</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Are the output vectors z_e close to the codes z_q ?</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    commit_loss <span class="op">=</span> jnp.mean(jnp.linalg.norm(z_e <span class="op">-</span> jax.lax.stop_gradient(z_q), <span class="bu">ord</span><span class="op">=</span><span class="dv">2</span>, axis<span class="op">=</span>(<span class="dv">1</span>,<span class="dv">2</span>)))</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    total_loss <span class="op">=</span> reconstruct_loss <span class="op">+</span> commit_loss</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_loss, (reconstruct_loss, commit_loss, codebook_updates, y)</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="at">@eqx.filter_jit</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_step(model, optimizer, opt_state, x, key):</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    (total_loss, (reconstruct_loss, commit_loss, codebook_updates, y)), grads <span class="op">=</span> calculate_losses(model, x)</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    updates, opt_state <span class="op">=</span> optimizer.update(grads, opt_state, model)</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> eqx.apply_updates(model, updates)</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> update_codebook_ema(model, codebook_updates[<span class="dv">0</span>], codebook_updates[<span class="dv">1</span>], key)</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> model, opt_state, total_loss, reconstruct_loss, commit_loss, codebook_updates, y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="preparing-the-data" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="preparing-the-data"><span class="header-section-number">4.3</span> Preparing the data</h2>
<p>Let’s download some data and make runs through to see if it can learn from it !</p>
<p>XTTS has this function that seems to transform the incoming wav files into nice mel_spectrograms. To optimize the time spent loading the data, we’ll transform all the data into input arrays first, and then during the run load from those instead.</p>
<div id="cell-40" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dvae_wav_to_mel(</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    wav, mel_norms_file<span class="op">=</span><span class="st">"../experiments/clips_mel_norms.pth"</span>, mel_norms<span class="op">=</span><span class="va">None</span>, device<span class="op">=</span>torch.device(<span class="st">"cpu"</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    mel_stft <span class="op">=</span> torchaudio.transforms.MelSpectrogram(</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        n_fft<span class="op">=</span><span class="dv">1024</span>,</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        hop_length<span class="op">=</span><span class="dv">256</span>,</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        win_length<span class="op">=</span><span class="dv">1024</span>,</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        power<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        normalized<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        sample_rate<span class="op">=</span><span class="dv">22050</span>,</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        f_min<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        f_max<span class="op">=</span><span class="dv">8000</span>,</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        n_mels<span class="op">=</span><span class="dv">80</span>,</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        norm<span class="op">=</span><span class="st">"slaney"</span>,</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    ).to(device)</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    wav <span class="op">=</span> wav.to(device)</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    mel <span class="op">=</span> mel_stft(wav)</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    mel <span class="op">=</span> torch.log(torch.clamp(mel, <span class="bu">min</span><span class="op">=</span><span class="fl">1e-5</span>))</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mel_norms <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>        mel_norms <span class="op">=</span> torch.load(mel_norms_file, map_location<span class="op">=</span>device)</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    mel <span class="op">=</span> mel <span class="op">/</span> mel_norms.unsqueeze(<span class="dv">0</span>).unsqueeze(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mel</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We’ll be using LJSpeech <span class="citation" data-cites="ljspeech17">(<a href="#ref-ljspeech17" role="doc-biblioref">Ito and Johnson 2017</a>)</span> as a dataset because it has just the right amount of samples to get some real training.</p>
<div id="cell-42" class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>wget https:<span class="op">//</span>data.keithito.com<span class="op">/</span>data<span class="op">/</span>speech<span class="op">/</span>LJSpeech<span class="op">-</span><span class="fl">1.1</span>.tar.bz2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-43" class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>tar <span class="op">-</span>xvjf .<span class="op">/</span>LJSpeech<span class="op">-</span><span class="fl">1.1</span>.tar.bz2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-44" class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torchaudio</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> librosa</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm <span class="im">import</span> tqdm</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>sample_rate <span class="op">=</span> <span class="dv">22050</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dvae_wav_to_mel(</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    wav, mel_norms_file<span class="op">=</span><span class="st">"./mel_stats.pth"</span>, mel_norms<span class="op">=</span><span class="va">None</span>, device<span class="op">=</span>torch.device(<span class="st">"cpu"</span>)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    mel_stft <span class="op">=</span> torchaudio.transforms.MelSpectrogram(</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        n_fft<span class="op">=</span><span class="dv">1024</span>,</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        hop_length<span class="op">=</span><span class="dv">256</span>,</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        win_length<span class="op">=</span><span class="dv">1024</span>,</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>        power<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>        normalized<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>        sample_rate<span class="op">=</span><span class="dv">22050</span>,</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>        f_min<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>        f_max<span class="op">=</span><span class="dv">8000</span>,</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>        n_mels<span class="op">=</span><span class="dv">80</span>,</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>        norm<span class="op">=</span><span class="st">"slaney"</span>,</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    ).to(device)</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    wav <span class="op">=</span> wav.to(device)</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    mel <span class="op">=</span> mel_stft(wav)</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>    mel <span class="op">=</span> torch.log(torch.clamp(mel, <span class="bu">min</span><span class="op">=</span><span class="fl">1e-5</span>))</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mel_norms <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>        mel_norms <span class="op">=</span> torch.load(mel_norms_file, map_location<span class="op">=</span>device)</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>    mel <span class="op">=</span> mel <span class="op">/</span> mel_norms.unsqueeze(<span class="dv">0</span>).unsqueeze(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mel</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>dataset_dest_path <span class="op">=</span> <span class="st">"dataset/mels"</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>files <span class="op">=</span> <span class="bu">list</span>(Path(<span class="st">"./LJSpeech-1.1"</span>).rglob(<span class="st">"*.wav"</span>))</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> boop():</span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> tqdm(files):</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>        y, sr <span class="op">=</span> librosa.load(<span class="bu">file</span>)</span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> sr <span class="op">!=</span> sample_rate:</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> librosa.resample(y, orig_sr<span class="op">=</span>sr, target_sr<span class="op">=</span>sample_rate)</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> torch.from_numpy(y)</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a>        mel <span class="op">=</span> dvae_wav_to_mel(y)</span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> mel.cpu().numpy()</span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a>        save_path <span class="op">=</span> Path(dataset_dest_path, <span class="ss">f"</span><span class="sc">{</span><span class="bu">file</span><span class="sc">.</span>stem<span class="sc">}</span><span class="ss">.npy"</span>)</span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a>        numpy.save(save_path, data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now that we have a folder full of mel spectrograms ready to be fed into our model, we can start the training ! Below, we do multiple things:</p>
<p>Initialize the model, the optimizer that will nugde it based on the losses our function returns, logging with tensorboard and saving the model every epoch.</p>
</section>
<section id="actually-training" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="actually-training"><span class="header-section-number">4.4</span> Actually training</h2>
<div id="cell-46" class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display, clear_output</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> datetime</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>dataset_path <span class="op">=</span> <span class="st">"dataset/mels"</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>mel_file_paths <span class="op">=</span> os.listdir(dataset_path)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> truncate_and_pad(audio: jax.Array, width: <span class="bu">int</span> <span class="op">=</span> <span class="dv">300</span>):</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    audio_length <span class="op">=</span> audio.shape[<span class="dv">1</span>]</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    target_length <span class="op">=</span> <span class="bu">int</span>(width)</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> audio_length <span class="op">&gt;</span> target_length:</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>        audio <span class="op">=</span> audio[:, :target_length]</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>        audio <span class="op">=</span> jnp.pad(audio, ((<span class="dv">0</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="bu">max</span>(<span class="dv">0</span>, target_length <span class="op">-</span> audio_length))))</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> audio</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_batch(idx: <span class="bu">list</span>):</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    batch <span class="op">=</span> []</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="bu">id</span> <span class="kw">in</span> idx:</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>        array <span class="op">=</span> jax.numpy.load(os.path.join(dataset_path, mel_file_paths[<span class="bu">id</span>]))[<span class="dv">0</span>]</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>        padded <span class="op">=</span> truncate_and_pad(array)</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>        batch.append(padded)</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jax.numpy.array(batch)</span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>key <span class="op">=</span> jax.random.PRNGKey(<span class="dv">69</span>)</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>key1, key2 <span class="op">=</span> jax.random.split(key, <span class="dv">2</span>)</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> VQVAE(key<span class="op">=</span>key1)</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> optax.adam(<span class="fl">1e-4</span>)</span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>opt_state <span class="op">=</span> optimizer.init(model)</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>writer <span class="op">=</span> SummaryWriter(log_dir<span class="op">=</span><span class="st">'./runs/'</span> <span class="op">+</span> datetime.datetime.now().strftime(<span class="st">"%Y%m</span><span class="sc">%d</span><span class="st">-%H%M%S"</span>))</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>epochs <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">2</span>)</span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>fig.show()</span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(epochs):</span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>    key, grab <span class="op">=</span> jax.random.split(key, <span class="dv">2</span>)</span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>    perm <span class="op">=</span> jax.random.permutation(grab, <span class="bu">len</span>(mel_file_paths))</span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a>    eqx.tree_serialise_leaves(<span class="ss">f"checkpoints/</span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">.eqx"</span>, model)</span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(mel_file_paths), batch_size):</span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a>        key, grab <span class="op">=</span> jax.random.split(key, <span class="dv">2</span>)</span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a>        batch_ids <span class="op">=</span> perm[i: i <span class="op">+</span> batch_size]</span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>        batch <span class="op">=</span> get_batch(batch_ids)</span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a>        model, opt_state, total_loss, reconstruct_loss, commit_loss, codebook_updates, y <span class="op">=</span> make_step(model, optimizer, opt_state, batch, grab)</span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-58"><a href="#cb21-58" aria-hidden="true" tabindex="-1"></a>        step <span class="op">=</span> epoch <span class="op">*</span> <span class="bu">len</span>(mel_file_paths) <span class="op">+</span> i</span>
<span id="cb21-59"><a href="#cb21-59" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Log codebook updates to TensorBoard</span></span>
<span id="cb21-60"><a href="#cb21-60" aria-hidden="true" tabindex="-1"></a>        writer.add_scalar(<span class="st">'Loss/Total'</span>, total_loss, step)</span>
<span id="cb21-61"><a href="#cb21-61" aria-hidden="true" tabindex="-1"></a>        writer.add_scalar(<span class="st">'Loss/Reconstruct'</span>, reconstruct_loss, step)</span>
<span id="cb21-62"><a href="#cb21-62" aria-hidden="true" tabindex="-1"></a>        writer.add_scalar(<span class="st">'Loss/Commit'</span>, commit_loss, step)</span>
<span id="cb21-63"><a href="#cb21-63" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-64"><a href="#cb21-64" aria-hidden="true" tabindex="-1"></a>        writer.add_histogram(<span class="st">'Codebook Updates/Code ids used'</span>, jnp.reshape(codebook_updates[<span class="dv">1</span>], <span class="op">-</span><span class="dv">1</span>), step)</span>
<span id="cb21-65"><a href="#cb21-65" aria-hidden="true" tabindex="-1"></a>        writer.add_histogram(<span class="st">'Codebook Updates/Code means'</span>, jnp.mean(codebook_updates[<span class="dv">0</span>][<span class="dv">2</span>], axis<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">2</span>)), step)</span>
<span id="cb21-66"><a href="#cb21-66" aria-hidden="true" tabindex="-1"></a>        writer.add_histogram(<span class="st">'Codebook Updates/Code stds'</span>, jnp.std(codebook_updates[<span class="dv">0</span>][<span class="dv">2</span>], axis<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">2</span>)), step)</span>
<span id="cb21-67"><a href="#cb21-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (i <span class="op">//</span> batch_size) <span class="op">%</span> <span class="dv">20</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb21-68"><a href="#cb21-68" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(batch.shape)</span>
<span id="cb21-69"><a href="#cb21-69" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(y.shape)</span>
<span id="cb21-70"><a href="#cb21-70" aria-hidden="true" tabindex="-1"></a>            ax1.clear()</span>
<span id="cb21-71"><a href="#cb21-71" aria-hidden="true" tabindex="-1"></a>            ax2.clear()</span>
<span id="cb21-72"><a href="#cb21-72" aria-hidden="true" tabindex="-1"></a>            ax1.imshow(batch[<span class="dv">0</span>], aspect<span class="op">=</span><span class="st">'auto'</span>, origin<span class="op">=</span><span class="st">'lower'</span>)</span>
<span id="cb21-73"><a href="#cb21-73" aria-hidden="true" tabindex="-1"></a>            ax2.imshow(y[<span class="dv">0</span>], aspect<span class="op">=</span><span class="st">'auto'</span>, origin<span class="op">=</span><span class="st">'lower'</span>)</span>
<span id="cb21-74"><a href="#cb21-74" aria-hidden="true" tabindex="-1"></a>            display(fig)</span>
<span id="cb21-75"><a href="#cb21-75" aria-hidden="true" tabindex="-1"></a>            clear_output(wait<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb21-76"><a href="#cb21-76" aria-hidden="true" tabindex="-1"></a>    <span class="co"># plt.imshow(y[0])</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With a little bit of patience, we can see the output image start to resemble more and more the input one !</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="assets/result.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Result after just 10 minutes of training on a NVIDIA L40"><img src="assets/result.png" class="img-fluid figure-img" alt="Result after just 10 minutes of training on a NVIDIA L40"></a></p>
<figcaption>Result after just 10 minutes of training on a NVIDIA L40</figcaption>
</figure>
</div>
<p>In the tensorboard we can also see that the codewords are progressively all used by the same amount during training. It’s beautiful 🥰</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="VQVAE_files/figure-html/cell-49-1-CleanShot%202024-11-06%20at%2017.06.34@2x.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Codebooks slowly all being used uniformily."><img src="VQVAE_files/figure-html/cell-49-1-CleanShot%202024-11-06%20at%2017.06.34@2x.png" class="img-fluid figure-img" alt="Codebooks slowly all being used uniformily."></a></p>
<figcaption>Codebooks slowly all being used uniformily.</figcaption>
</figure>
</div>
<p>This concludes this chapter, if you have any questions or remarks feel free to reach out to me ! <span class="citation" data-cites="sxyBoi">(<a href="#ref-sxyBoi" role="doc-biblioref"><strong>sxyBoi?</strong></a>)</span> on Telegram 😅</p>
</section>
</section>
<section id="references" class="level1 unnumbered" data-number="5">


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">5 References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-casanova2024xttsmassivelymultilingualzeroshot" class="csl-entry" role="listitem">
Casanova, Edresson, Kelly Davis, Eren Gölge, Görkem Göknar, Iulian Gulea, Logan Hart, Aya Aljafari, et al. 2024. <span>“XTTS: A Massively Multilingual Zero-Shot Text-to-Speech Model.”</span> <a href="https://arxiv.org/abs/2406.04904">https://arxiv.org/abs/2406.04904</a>.
</div>
<div id="ref-défossez2022highfidelityneuralaudio" class="csl-entry" role="listitem">
Défossez, Alexandre, Jade Copet, Gabriel Synnaeve, and Yossi Adi. 2022. <span>“High Fidelity Neural Audio Compression.”</span> <a href="https://arxiv.org/abs/2210.13438">https://arxiv.org/abs/2210.13438</a>.
</div>
<div id="ref-dumakude2023automated_image" class="csl-entry" role="listitem">
Dumakude, A., and A. E. Ezugwu. 2023. <span>“Image from "Automated COVID-19 Detection with Convolutional Neural Networks".”</span> <em>Scientific Reports</em> 13: 10607. <a href="https://doi.org/10.1038/s41598-023-37743-4">https://doi.org/10.1038/s41598-023-37743-4</a>.
</div>
<div id="ref-understanding_vae" class="csl-entry" role="listitem">
Irhum Shafkat. 2018. <a href="https://towardsdatascience.com/intuitively-understanding-variational-autoencoders-1bfe67eb5daf">https://towardsdatascience.com/intuitively-understanding-variational-autoencoders-1bfe67eb5daf</a>.
</div>
<div id="ref-ljspeech17" class="csl-entry" role="listitem">
Ito, Keith, and Linda Johnson. 2017. <span>“The LJ Speech Dataset.”</span> <a href="https://keithito.com/LJ-Speech-Dataset/" class="uri">https://keithito.com/LJ-Speech-Dataset/</a>.
</div>
<div id="ref-oord2018neuraldiscreterepresentationlearning" class="csl-entry" role="listitem">
Oord, Aaron van den, Oriol Vinyals, and Koray Kavukcuoglu. 2018. <span>“Neural Discrete Representation Learning.”</span> <a href="https://arxiv.org/abs/1711.00937">https://arxiv.org/abs/1711.00937</a>.
</div>
<div id="ref-csdn_image_2024" class="csl-entry" role="listitem">
平亦舸. 2024. <span>“Image from "Csdn".”</span> <a href="https://blog.csdn.net/m0_56214772/article/details/129711670">https://blog.csdn.net/m0_56214772/article/details/129711670</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>